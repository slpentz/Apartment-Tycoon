<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
    <title>Apartment Tycoon (Mobile Multiplayer Prototype)</title>
    <style>
        :root {
            --bg: #0f1220;
            --panel: #171b2e;
            --panel2: #1e2440;
            --text: #e9ecff;
            --muted: #a9b0d9;
            --good: #45d483;
            --bad: #ff5b6b;
            --warn: #ffd166;
            --line: rgba(255,255,255,.12);
            --shadow: 0 10px 30px rgba(0,0,0,.25);
            --r: 14px;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
            background: radial-gradient(1200px 600px at 20% 0%, #1a2150 0%, var(--bg) 50%) fixed;
            color: var(--text);
        }

        header {
            padding: 12px 14px;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 10px;
        }

            header h1 {
                font-size: 16px;
                margin: 0;
                letter-spacing: .2px;
            }

            header .sub {
                font-size: 12px;
                color: var(--muted);
                margin-top: 2px;
            }

            header .right {
                display: flex;
                gap: 8px;
                align-items: center;
            }

        button {
            background: #2b3570;
            color: var(--text);
            border: 1px solid rgba(255,255,255,.18);
            border-radius: 12px;
            padding: 11px 14px;
            font-weight: 750;
            cursor: pointer;
            transition: transform .06s ease, filter .12s ease;
            touch-action: manipulation;
        }

            button:hover {
                filter: brightness(1.07);
            }

            button:active {
                transform: translateY(1px);
            }

            button.secondary {
                background: rgba(255,255,255,.06);
            }

            button.danger {
                background: #5b1b28;
            }

            button.good {
                background: #1d5a3a;
            }

            button:disabled {
                opacity: .5;
                cursor: not-allowed;
            }

        input[type="number"], input[type="text"] {
            background: rgba(255,255,255,.06);
            border: 1px solid rgba(255,255,255,.18);
            color: var(--text);
            border-radius: 12px;
            padding: 10px 12px;
            outline: none;
            width: 120px;
            max-width: 100%;
        }

        label {
            font-size: 12px;
            color: var(--muted);
        }

        .pill {
            display: inline-flex;
            gap: 7px;
            align-items: center;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.04);
            font-size: 12px;
            color: var(--muted);
            white-space: nowrap;
        }

        .dot {
            width: 10px;
            height: 10px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,.35);
            background: transparent;
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            padding: 12px;
            padding-bottom: calc(12px + env(safe-area-inset-bottom));
        }

        .card {
            background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
            border: 1px solid var(--line);
            border-radius: var(--r);
            overflow: hidden;
            box-shadow: var(--shadow);
        }

        .hd {
            padding: 12px;
            border-bottom: 1px solid var(--line);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            background: rgba(0,0,0,.16);
        }

        .title {
            font-size: 12px;
            letter-spacing: .2px;
            color: var(--muted);
            text-transform: uppercase;
        }

        .bd {
            padding: 12px;
        }

        .row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .hint {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.35;
        }

        .hr {
            height: 1px;
            background: var(--line);
            margin: 12px 0;
        }

        /* Tabs (mobile-first) */
        .tabs {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 10px;
        }

        .tabBtn {
            padding: 10px 8px;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,.14);
            background: rgba(255,255,255,.05);
            color: var(--muted);
            font-weight: 800;
            font-size: 12px;
        }

            .tabBtn.active {
                background: rgba(123,155,255,.18);
                color: var(--text);
                border-color: rgba(123,155,255,.30);
            }

        .tabPanel {
            display: none;
        }

            .tabPanel.active {
                display: block;
            }

        /* Board canvas */
        canvas {
            width: 100%;
            height: 58vh;
            min-height: 420px;
            display: block;
            background: rgba(0,0,0,.18);
            border-top: 1px solid var(--line);
            touch-action: none;
        }

        /* Lists */
        .list {
            max-height: 340px;
            overflow: auto;
            border: 1px solid var(--line);
            border-radius: 12px;
            background: rgba(0,0,0,.16);
            padding: 8px;
        }

        .listItem {
            border: 1px solid rgba(255,255,255,.10);
            background: rgba(255,255,255,.04);
            border-radius: 12px;
            padding: 10px;
            margin-bottom: 10px;
        }

            .listItem:last-child {
                margin-bottom: 0;
            }

        .big {
            font-size: 14px;
            font-weight: 900;
            margin-bottom: 4px;
        }

        .mini {
            font-size: 12px;
            color: var(--muted);
            line-height: 1.35;
        }

        .badge {
            display: inline-block;
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,.14);
            background: rgba(0,0,0,.18);
            color: var(--muted);
            margin-left: 6px;
            vertical-align: middle;
        }

        .log {
            height: 320px;
            overflow: auto;
            border: 1px solid var(--line);
            border-radius: 12px;
            background: rgba(0,0,0,.18);
            padding: 10px;
            font-size: 12px;
            line-height: 1.35;
        }

            .log .line {
                margin-bottom: 9px;
            }

        .goodTxt {
            color: var(--good);
        }

        .badTxt {
            color: var(--bad);
        }

        .warnTxt {
            color: var(--warn);
        }

        /* Players */
        .players {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .playerBox {
            border: 1px solid var(--line);
            background: rgba(0,0,0,.14);
            border-radius: 12px;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: flex-start;
            justify-content: space-between;
        }

            .playerBox.active {
                outline: 2px solid rgba(123,155,255,.25);
                box-shadow: 0 0 0 2px rgba(123,155,255,.10);
            }

        .playerLeft {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .token {
            width: 14px;
            height: 14px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,.45);
        }

        .playerName {
            font-weight: 900;
            font-size: 13px;
        }

        .kv {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            font-size: 12px;
            color: var(--muted);
        }

        .setupGrid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        @media (max-width:520px) {
            .setupGrid {
                grid-template-columns: 1fr;
            }

            header {
                align-items: flex-start;
            }

                header .right {
                    flex-wrap: wrap;
                    justify-content: flex-end;
                }

            button {
                width: auto;
            }

            input[type="number"] {
                width: 100%;
            }
        }
    </style>
</head>

<body>
    <header>
        <div>
            <h1>Apartment Tycoon <span class="sub">(mobile pass-and-play)</span></h1>
            <div class="sub">60 spaces ‚Ä¢ unique-color sets ‚Ä¢ set sizes 2‚Äì3 ‚Ä¢ Apartment + Building cards ‚Ä¢ bed upgrades</div>
        </div>
        <div class="right">
            <button class="secondary" id="btnNew">New Game</button>
            <button class="secondary" id="btnClearLog">Clear Log</button>
        </div>
    </header>

    <div class="wrap">
        <div class="tabs">
            <button class="tabBtn active" data-tab="board">Board</button>
            <button class="tabBtn" data-tab="actions">Actions</button>
            <button class="tabBtn" data-tab="properties">Properties</button>
            <button class="tabBtn" data-tab="log">Log</button>
        </div>

        <!-- BOARD TAB -->
        <section class="card tabPanel active" id="tab-board">
            <div class="hd">
                <div class="title">Board</div>
                <div class="row">
                    <span class="pill"><span class="dot" id="turnDot"></span><span id="turnLabel">Not started</span></span>
                    <span class="pill">Dice: <b id="diceOut">‚Äì</b></span>
                </div>
            </div>
            <canvas id="board" width="1200" height="740"></canvas>
            <div class="bd">
                <div class="hint">
                    Beds: 0 Bare ‚Üí 5 Luxury. Own a full set (2‚Äì3 units) for a rent bonus.
                </div>
            </div>
        </section>

        <!-- ACTIONS TAB -->
        <section class="card tabPanel" id="tab-actions" style="margin-top:12px;">
            <div class="hd">
                <div class="title">Actions</div>
                <div class="row">
                    <span class="pill">Beds: <b>0‚Äì5</b></span>
                    <span class="pill">Pass Start: <b>$200</b></span>
                </div>
            </div>
            <div class="bd">
                <div id="setup">
                    <div class="setupGrid">
                        <div class="listItem">
                            <div class="big">Setup</div>
                            <div class="mini">Choose players + starting cash, then Start.</div>
                            <div class="hr"></div>
                            <div class="row">
                                <label>Players (2‚Äì4)</label>
                                <input type="number" id="numPlayers" min="2" max="4" value="2" />
                            </div>
                            <div class="row" style="margin-top:10px;">
                                <label>Starting cash</label>
                                <input type="number" id="startCash" min="500" step="100" value="1500" />
                            </div>
                            <div class="row" style="margin-top:12px;">
                                <button class="good" id="btnStart">Start</button>
                            </div>
                        </div>

                        <div class="listItem">
                            <div class="big">Rules (prototype)</div>
                            <div class="mini">
                                <ul style="margin:8px 0 0 18px; padding:0;">
                                    <li>Roll ‚Üí move ‚Üí resolve space.</li>
                                    <li>Unowned apartment: you can Buy.</li>
                                    <li>Owned by someone else: rent auto-paid.</li>
                                    <li>Upgrade: beds 0‚Üí5, increases rent.</li>
                                    <li>Complete a set: rent bonus.</li>
                                    <li>Apartment/Building card spaces trigger events.</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="gameUI" style="display:none;">
                    <div class="row">
                        <button id="btnRoll" class="good">Roll</button>
                        <button id="btnBuy">Buy</button>
                        <button id="btnUpgrade">Upgrade Bed</button>
                        <button id="btnEnd" class="secondary">End Turn</button>
                        <button id="btnForfeit" class="danger">Forfeit</button>
                    </div>

                    <div class="hr"></div>

                    <div class="title" style="margin-bottom:8px;">Current Space</div>
                    <div class="listItem" id="spaceInfo">
                        <div class="big">‚Äì</div>
                        <div class="mini">‚Äì</div>
                    </div>

                    <div class="title" style="margin:12px 0 8px;">Hint</div>
                    <div class="listItem">
                        <div class="big" id="hintTitle">‚Äì</div>
                        <div class="mini" id="hintText">Start the game, then roll.</div>
                    </div>

                    <div class="hr"></div>

                    <div class="title" style="margin-bottom:8px;">Players</div>
                    <div class="players" id="players"></div>
                </div>
            </div>
        </section>

        <!-- PROPERTIES TAB -->
        <section class="card tabPanel" id="tab-properties" style="margin-top:12px;">
            <div class="hd">
                <div class="title">Properties</div>
                <div class="row">
                    <span class="pill">Unowned Market + Your Owned</span>
                </div>
            </div>
            <div class="bd">
                <div class="title" style="margin-bottom:8px;">Market (Unowned)</div>
                <div class="list" id="market"></div>

                <div class="hr"></div>

                <div class="title" style="margin-bottom:8px;">Current Player Owned</div>
                <div class="list" id="owned"></div>
            </div>
        </section>

        <!-- LOG TAB -->
        <section class="card tabPanel" id="tab-log" style="margin-top:12px;">
            <div class="hd">
                <div class="title">Log</div>
                <div class="row">
                    <span class="pill">Events + Payments</span>
                </div>
            </div>
            <div class="bd">
                <div class="log" id="log"></div>
            </div>
        </section>
    </div>

    <script>
        (() => {
            // ---------- Crash banner ----------
            function showFatal(msg) {
                const box = document.createElement("div");
                box.style.cssText = "position:fixed;left:12px;right:12px;bottom:12px;z-index:9999;background:#5b1b28;color:#fff;border:1px solid rgba(255,255,255,.25);border-radius:12px;padding:10px;font:12px system-ui;";
                box.textContent = "Apartment Tycoon error: " + msg;
                document.body.appendChild(box);
            }
            window.addEventListener("error", (e) => showFatal(e.message));
            window.addEventListener("unhandledrejection", (e) => showFatal(e.reason?.message || String(e.reason)));

            // ---------- Constants ----------
            const TRACK_SIZE = 60;
            const BED_NAMES = ["Bare", "Twin", "Full", "Queen", "King", "Luxury"];

            const SPACE = {
                START: "START",
                APARTMENT: "APARTMENT",
                TAX: "TAX",
                CARD_APT: "CARD_APT",
                CARD_BLD: "CARD_BLD",
                TRANSIT: "TRANSIT",
                FREE: "FREE",
            };

            // ---------- Helpers ----------
            const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

            function shuffle(arr) {
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            }

            function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }

            // Distinct colors (unique per set)
            function generateDistinctColors(n) {
                const out = [];
                for (let i = 0; i < n; i++) {
                    const hue = Math.round((i * 360) / n);
                    const sat = 85;
                    const light = 55;
                    out.push(`hsl(${hue} ${sat}% ${light}%)`);
                }
                return out;
            }

            // ---------- Cards ----------
            const apartmentCards = [
                { title: "Tenant Boom", text: "Renters flood the market. Collect $100.", effect: (g, p) => cash(p, +100) },
                { title: "Late Rent", text: "You cover a shortfall. Pay $60.", effect: (g, p) => cash(p, -60) },
                { title: "Great Reviews", text: "Your next rent collected is doubled.", effect: (g, p) => { p.status.doubleNextRent = true; } },
                {
                    title: "Noise Complaint", text: "Pay $40 per bed level across your properties (max $200).", effect: (g, p) => {
                        const sumBeds = p.owned.reduce((a, id) => a + g.spaces[id].beds, 0);
                        cash(p, -Math.min(200, sumBeds * 40));
                    }
                },
                { title: "City Festival", text: "Advance 3 spaces.", effect: (g, p) => moveBy(g, p, 3, true) },
                { title: "Lease Renewal", text: "Collect $25 per apartment you own.", effect: (g, p) => cash(p, p.owned.length * 25) },
                {
                    title: "Broken Heater", text: "Downgrade one random owned apartment by 1 bed (min 0).", effect: (g, p) => {
                        if (!p.owned.length) return;
                        const id = p.owned[randInt(0, p.owned.length - 1)];
                        g.spaces[id].beds = Math.max(0, g.spaces[id].beds - 1);
                        log(`üõ†Ô∏è ${p.name} repair hit: ${g.spaces[id].name} now ${BED_NAMES[g.spaces[id].beds]}.`, "warnTxt");
                    }
                },
                { title: "Security Deposit", text: "Collect $80.", effect: (g, p) => cash(p, +80) },
            ];

            const buildingCards = [
                {
                    title: "Renovation Grant", text: "Upgrade one apartment for free (+1 bed).", effect: (g, p) => {
                        const upgradable = p.owned.filter(id => g.spaces[id].beds < 5);
                        if (!upgradable.length) return;
                        const id = upgradable[randInt(0, upgradable.length - 1)];
                        g.spaces[id].beds += 1;
                        log(`üèóÔ∏è Grant upgraded ${g.spaces[id].name} to ${BED_NAMES[g.spaces[id].beds]}.`, "goodTxt");
                    }
                },
                { title: "Property Tax Hike", text: "Pay 10% of your cash (min $50).", effect: (g, p) => cash(p, -Math.max(50, Math.floor(p.cash * 0.10))) },
                { title: "Appliance Package", text: "Next upgrade costs 50% less.", effect: (g, p) => { p.status.halfNextUpgrade = true; } },
                { title: "Inspection Pass", text: "Collect $70.", effect: (g, p) => cash(p, +70) },
                { title: "Elevator Failure", text: "Pay $80, then move back 2 spaces.", effect: (g, p) => { cash(p, -80); moveBy(g, p, -2, true); } },
                { title: "Investor Interest", text: "Next unowned apartment you land on is 20% off.", effect: (g, p) => { p.status.discountNextBuy = true; } },
                { title: "Contractor Overcharge", text: "Pay $120.", effect: (g, p) => cash(p, -120) },
                { title: "Community Partnerships", text: "Collect $40 per complete set you own.", effect: (g, p) => cash(p, countCompleteSets(g, p) * 40) },
            ];

            // ---------- Game State ----------
            let game = null;

            function currentPlayer(g) { return g.players[g.turn]; }
            function alivePlayers(g) { return g.players.filter(p => !p.bankrupt); }

            function newGameState(numPlayers = 2, startCash = 1500) {
                const spaces = buildBoard();
                const tokenColors = ["#7aa0ff", "#ff7aa0", "#7affc6", "#ffd07a"];
                const players = Array.from({ length: numPlayers }, (_, i) => ({
                    id: i,
                    name: `Player ${i + 1}`,
                    token: tokenColors[i],
                    pos: 0,
                    cash: startCash,
                    owned: [],
                    status: { doubleNextRent: false, halfNextUpgrade: false, discountNextBuy: false },
                    bankrupt: false,
                }));
                return {
                    turn: 0,
                    phase: "NEED_ROLL", // NEED_ROLL, RESOLVED
                    lastRoll: null,
                    spaces,
                    players,
                    decks: {
                        apt: shuffle([...apartmentCards]),
                        bld: shuffle([...buildingCards]),
                    },
                    discard: { apt: [], bld: [] }
                };
            }

            // ---------- Board Construction (UNIQUE COLOR SETS, sizes 2‚Äì3, no sharing) ----------
            function buildBoard() {
                const spaces = new Array(TRACK_SIZE).fill(null);

                // Specials: 18 fixed spaces
                const specials = new Map([
                    [0, { type: SPACE.START, name: "Move-In Day (Start)", text: "Collect $200 when you pass." }],
                    [5, { type: SPACE.CARD_APT, name: "Apartment Card", text: "Draw an Apartment Card." }],
                    [10, { type: SPACE.TAX, name: "City Tax", text: "Pay $150." }],
                    [12, { type: SPACE.CARD_BLD, name: "Building Card", text: "Draw a Building Card." }],
                    [15, { type: SPACE.TRANSIT, name: "Subway Station", text: "Jump ahead to nearest Card space." }],
                    [20, { type: SPACE.FREE, name: "Community Park", text: "Nothing happens." }],
                    [22, { type: SPACE.CARD_APT, name: "Apartment Card", text: "Draw an Apartment Card." }],
                    [25, { type: SPACE.TAX, name: "Maintenance Fee", text: "Pay $100." }],
                    [27, { type: SPACE.CARD_BLD, name: "Building Card", text: "Draw a Building Card." }],
                    [30, { type: SPACE.TRANSIT, name: "Moving Truck", text: "Go to Start, collect $200." }],
                    [35, { type: SPACE.CARD_APT, name: "Apartment Card", text: "Draw an Apartment Card." }],
                    [40, { type: SPACE.TAX, name: "Insurance Premium", text: "Pay $120." }],
                    [42, { type: SPACE.CARD_BLD, name: "Building Card", text: "Draw a Building Card." }],
                    [45, { type: SPACE.TRANSIT, name: "Real Estate Expo", text: "Move forward 5 spaces." }],
                    [50, { type: SPACE.FREE, name: "Coffee Shop", text: "Nothing happens." }],
                    [52, { type: SPACE.CARD_APT, name: "Apartment Card", text: "Draw an Apartment Card." }],
                    [55, { type: SPACE.TAX, name: "Utility Bill", text: "Pay $90." }],
                    [57, { type: SPACE.CARD_BLD, name: "Building Card", text: "Draw a Building Card." }],
                ]);

                const apartmentsNeeded = TRACK_SIZE - specials.size; // 42

                // Choose set sizes 2 or 3 that sum to 42.
                // Clean default: 14 sets of 3 (all sets size 3).
                // If you want a mix, replace with any pattern of 2/3 that totals 42.
                const SET_SIZES = Array(14).fill(3);

                const setCount = SET_SIZES.length;
                const setColors = generateDistinctColors(setCount);

                const apartments = [];
                for (let setNum = 0; setNum < setCount; setNum++) {
                    const size = SET_SIZES[setNum];
                    const color = setColors[setNum];
                    const tier = setNum + 1; // 1..setCount

                    for (let u = 0; u < size; u++) {
                        apartments.push({
                            type: SPACE.APARTMENT,
                            id: null,
                            setKey: `set-${setNum + 1}`,         // unique set id (NO sharing)
                            setName: `Set ${setNum + 1}`,
                            colorHex: color,                   // unique color per set
                            name: `Set ${setNum + 1} ‚Äì Unit ${u + 1}`,
                            price: 110 + tier * 18 + u * 12,
                            baseRent: 18 + tier * 4 + u * 3,
                            upgradeCost: 80 + tier * 16,
                            owner: null,
                            beds: 0,
                            text: "Buy it or pay rent if owned."
                        });
                    }
                }

                if (apartments.length !== apartmentsNeeded) {
                    throw new Error(`Apartment count mismatch: made ${apartments.length}, need ${apartmentsNeeded}`);
                }

                // Fill spaces
                let ai = 0;
                for (let i = 0; i < TRACK_SIZE; i++) {
                    if (specials.has(i)) {
                        spaces[i] = { id: i, ...specials.get(i) };
                    } else {
                        const apt = apartments[ai++];
                        if (!apt) throw new Error(`No apartment left to place at index ${i}.`);
                        apt.id = i;
                        spaces[i] = apt;
                    }
                }
                return spaces;
            }

            // ---------- Economy ----------
            function cash(p, amount) {
                p.cash += amount;
                if (amount >= 0) log(`üíµ ${p.name} +$${amount}. (Cash: $${p.cash})`, "goodTxt");
                else log(`üí∏ ${p.name} -$${Math.abs(amount)}. (Cash: $${p.cash})`, "badTxt");
            }

            function transferCash(from, to, amount) {
                from.cash -= amount;
                to.cash += amount;
                log(`‚û°Ô∏è $${amount} moved from ${from.name} to ${to.name}.`, "warnTxt");
            }

            function ownsCompleteSet(g, p, setKey) {
                const ids = g.spaces
                    .filter(s => s.type === SPACE.APARTMENT && s.setKey === setKey)
                    .map(s => s.id);
                return ids.length > 0 && ids.every(id => g.spaces[id].owner === p.id);
            }

            function countCompleteSets(g, p) {
                const setKeys = [...new Set(
                    g.spaces.filter(s => s.type === SPACE.APARTMENT).map(s => s.setKey)
                )];
                let count = 0;
                for (const key of setKeys) {
                    if (ownsCompleteSet(g, p, key)) count++;
                }
                return count;
            }

            function rentFor(space, g) {
                const bedMult = [1, 1.6, 2.4, 3.5, 5.0, 7.0];
                let rent = Math.round(space.baseRent * bedMult[space.beds]);
                const owner = g.players[space.owner];
                if (owner && ownsCompleteSet(g, owner, space.setKey)) {
                    rent = Math.round(rent * 1.25);
                }
                return rent;
            }

            function upgradePrice(space, player) {
                let cost = space.upgradeCost;
                if (player.status.halfNextUpgrade) cost = Math.ceil(cost * 0.5);
                return cost;
            }

            function buyPrice(space, player) {
                let cost = space.price;
                if (player.status.discountNextBuy) cost = Math.ceil(cost * 0.8);
                return cost;
            }

            function taxAmount(space) {
                if (space.name.includes("City")) return 150;
                if (space.name.includes("Maintenance")) return 100;
                if (space.name.includes("Insurance")) return 120;
                if (space.name.includes("Utility")) return 90;
                return 100;
            }

            // ---------- Movement / Resolution ----------
            function moveBy(g, p, delta, resolveNow = false) {
                const old = p.pos;
                let next = (p.pos + delta) % TRACK_SIZE;
                if (next < 0) next += TRACK_SIZE;

                // passing start only when moving forward across index 0
                if (delta > 0 && (old + delta) >= TRACK_SIZE) {
                    cash(p, +200);
                    log(`üèÅ ${p.name} passed Start and collected $200.`, "goodTxt");
                }

                p.pos = next;
                if (resolveNow) resolveSpace(g);
            }

            function drawCard(g, which) {
                const deck = g.decks[which];
                const discard = g.discard[which];
                if (deck.length === 0) {
                    g.decks[which] = shuffle(discard.splice(0));
                }
                return g.decks[which].shift();
            }

            function resolveSpace(g) {
                const p = currentPlayer(g);
                if (p.bankrupt) return;

                const s = g.spaces[p.pos];
                renderSpaceInfo(s, g);

                if (s.type === SPACE.START) {
                    log(`üè† ${p.name} landed on Start.`, "warnTxt");
                }

                if (s.type === SPACE.TAX) {
                    const amount = taxAmount(s);
                    log(`üèõÔ∏è ${p.name} landed on ${s.name}.`, "warnTxt");
                    cash(p, -amount);
                }

                if (s.type === SPACE.FREE) {
                    log(`‚òï ${p.name} landed on ${s.name}. Nothing happens.`, "warnTxt");
                }

                if (s.type === SPACE.TRANSIT) {
                    log(`üöá ${p.name} hit ${s.name}.`, "warnTxt");
                    if (p.pos === 15) {
                        const cardSpaces = [5, 12, 22, 27, 35, 42, 52, 57];
                        let best = null;
                        for (const idx of cardSpaces) {
                            const dist = (idx - p.pos + TRACK_SIZE) % TRACK_SIZE;
                            if (dist === 0) continue;
                            if (best === null || dist < best.dist) best = { idx, dist };
                        }
                        moveBy(g, p, best.dist, true);
                        return;
                    }
                    if (p.pos === 30) {
                        p.pos = 0;
                        cash(p, +200);
                        log(`üöö ${p.name} moved to Start and collected $200.`, "goodTxt");
                    }
                    if (p.pos === 45) {
                        moveBy(g, p, 5, true);
                        return;
                    }
                }

                if (s.type === SPACE.CARD_APT) {
                    const card = drawCard(g, "apt");
                    log(`üì¶ Apartment Card: ${card.title} ‚Äî ${card.text}`, "warnTxt");
                    card.effect(g, p);
                }

                if (s.type === SPACE.CARD_BLD) {
                    const card = drawCard(g, "bld");
                    log(`üèóÔ∏è Building Card: ${card.title} ‚Äî ${card.text}`, "warnTxt");
                    card.effect(g, p);
                }

                if (s.type === SPACE.APARTMENT) {
                    if (s.owner === null) {
                        log(`üè¢ ${p.name} landed on unowned ${s.name}. Price $${s.price}.`, "warnTxt");
                    } else if (s.owner === p.id) {
                        log(`üîë ${p.name} landed on their own ${s.name}.`, "goodTxt");
                    } else {
                        const owner = g.players[s.owner];
                        const baseRent = rentFor(s, g);
                        let pay = baseRent;

                        log(`üßæ ${p.name} owes rent $${baseRent} to ${owner.name} for ${s.name} (${BED_NAMES[s.beds]}).`, "badTxt");

                        if (owner.status.doubleNextRent) {
                            pay = baseRent * 2;
                            owner.status.doubleNextRent = false;
                            log(`‚ú® ${owner.name}'s "double next rent" triggered! Rent doubled to $${pay}.`, "warnTxt");
                        }

                        transferCash(p, owner, pay);
                    }
                }

                g.phase = "RESOLVED";
                updateUI();
                checkBankruptcy(g);
                checkWin(g);
            }

            function checkBankruptcy(g) {
                for (const p of g.players) {
                    if (!p.bankrupt && p.cash < 0) {
                        p.bankrupt = true;
                        // release properties
                        for (const id of p.owned) {
                            const s = g.spaces[id];
                            s.owner = null;
                            s.beds = 0;
                        }
                        p.owned = [];
                        log(`üí• ${p.name} is BANKRUPT. Properties return to the market.`, "badTxt");
                    }
                }
            }

            function checkWin(g) {
                const alive = alivePlayers(g);
                if (alive.length === 1) {
                    log(`üèÜ ${alive[0].name} wins Apartment Tycoon!`, "goodTxt");
                    disableActions(true);
                }
            }

            // ---------- Actions ----------
            function roll() {
                const g = game;
                const p = currentPlayer(g);
                if (g.phase !== "NEED_ROLL") return;

                const d1 = randInt(1, 6);
                const d2 = randInt(1, 6);
                const sum = d1 + d2;

                g.lastRoll = { d1, d2, sum };
                $("diceOut").textContent = `${d1} + ${d2} = ${sum}`;
                log(`üé≤ ${p.name} rolled ${d1} and ${d2} (total ${sum}).`, "warnTxt");

                moveBy(g, p, sum, false);
                resolveSpace(g);
            }

            function buy() {
                const g = game;
                const p = currentPlayer(g);
                if (g.phase !== "RESOLVED") return;

                const s = g.spaces[p.pos];
                if (s.type !== SPACE.APARTMENT || s.owner !== null) return;

                const cost = buyPrice(s, p);
                if (p.cash < cost) {
                    log(`‚ùå Not enough cash to buy ${s.name}. Need $${cost}.`, "badTxt");
                    return;
                }

                p.cash -= cost;
                s.owner = p.id;
                p.owned.push(s.id);

                log(`‚úÖ ${p.name} bought ${s.name} for $${cost}.`, "goodTxt");

                if (p.status.discountNextBuy) {
                    p.status.discountNextBuy = false;
                    log(`üìâ Buy discount used up.`, "warnTxt");
                }

                updateUI();
            }

            function upgrade() {
                const g = game;
                const p = currentPlayer(g);
                if (g.phase !== "RESOLVED") return;

                // Prefer upgrading the space you're on if owned, otherwise cheapest upgradable
                let target = g.spaces[p.pos];
                if (!(target.type === SPACE.APARTMENT && target.owner === p.id && target.beds < 5)) {
                    const upgradable = p.owned
                        .map(id => g.spaces[id])
                        .filter(s => s.beds < 5)
                        .sort((a, b) => upgradePrice(a, p) - upgradePrice(b, p));
                    if (!upgradable.length) {
                        log(`‚ÑπÔ∏è No properties available to upgrade.`, "warnTxt");
                        return;
                    }
                    target = upgradable[0];
                }

                const cost = upgradePrice(target, p);
                if (p.cash < cost) {
                    log(`‚ùå Not enough cash to upgrade. Need $${cost}.`, "badTxt");
                    return;
                }

                p.cash -= cost;
                target.beds += 1;

                log(`üõèÔ∏è ${p.name} upgraded ${target.name} to ${BED_NAMES[target.beds]} (Beds ${target.beds}). Cost $${cost}.`, "goodTxt");

                if (p.status.halfNextUpgrade) {
                    p.status.halfNextUpgrade = false;
                    log(`üß∞ Half-price upgrade used up.`, "warnTxt");
                }

                updateUI();
            }

            function endTurn() {
                const g = game;
                if (g.phase === "NEED_ROLL") return;

                do {
                    g.turn = (g.turn + 1) % g.players.length;
                } while (g.players[g.turn].bankrupt);

                g.phase = "NEED_ROLL";
                g.lastRoll = null;
                $("diceOut").textContent = "‚Äì";

                log(`‚û°Ô∏è Turn passes to ${currentPlayer(g).name}.`, "warnTxt");
                updateUI();
            }

            function forfeit() {
                const g = game;
                const p = currentPlayer(g);
                p.cash = -1;
                checkBankruptcy(g);
                updateUI();
                checkWin(g);
                if (alivePlayers(g).length > 1) endTurn();
            }

            // ---------- Rendering ----------
            const canvas = document.getElementById("board");
            const ctx = canvas.getContext("2d");

            function roundRect(x, y, w, h, r) {
                ctx.beginPath();
                ctx.moveTo(x + r, y);
                ctx.arcTo(x + w, y, x + w, y + h, r);
                ctx.arcTo(x + w, y + h, x, y + h, r);
                ctx.arcTo(x, y + h, x, y, r);
                ctx.arcTo(x, y, x + w, y, r);
                ctx.closePath();
            }

            function drawBoard(g) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                const cx = canvas.width / 2;
                const cy = canvas.height / 2 + 10;
                const rx = 430;
                const ry = 250;

                ctx.save();
                ctx.strokeStyle = "rgba(255,255,255,.12)";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2);
                ctx.stroke();
                ctx.restore();

                const points = [];
                for (let i = 0; i < TRACK_SIZE; i++) {
                    const t = (i / TRACK_SIZE) * Math.PI * 2 - Math.PI / 2;
                    points.push({
                        x: cx + rx * Math.cos(t),
                        y: cy + ry * Math.sin(t)
                    });
                }

                for (let i = 0; i < TRACK_SIZE; i++) {
                    const s = g.spaces[i];
                    const pt = points[i];

                    const w = 70;
                    const h = 28;

                    ctx.save();
                    ctx.translate(pt.x, pt.y);

                    const ang = Math.atan2(pt.y - cy, pt.x - cx);
                    ctx.rotate(ang);

                    // base
                    ctx.fillStyle = "rgba(255,255,255,.06)";
                    ctx.strokeStyle = "rgba(255,255,255,.12)";
                    ctx.lineWidth = 1;
                    roundRect(-w / 2, -h / 2, w, h, 10);
                    ctx.fill();
                    ctx.stroke();

                    // stripe
                    let stripe = "rgba(255,255,255,.10)";
                    if (s.type === SPACE.APARTMENT) stripe = s.colorHex;
                    if (s.type === SPACE.START) stripe = "rgba(122,160,255,.9)";
                    if (s.type === SPACE.TAX) stripe = "rgba(255,91,107,.9)";
                    if (s.type === SPACE.CARD_APT) stripe = "rgba(255,209,102,.9)";
                    if (s.type === SPACE.CARD_BLD) stripe = "rgba(69,212,131,.9)";
                    if (s.type === SPACE.TRANSIT) stripe = "rgba(155,93,229,.9)";
                    if (s.type === SPACE.FREE) stripe = "rgba(255,255,255,.25)";

                    ctx.fillStyle = stripe;
                    roundRect(-w / 2, -h / 2, 8, h, 6);
                    ctx.fill();

                    // index
                    ctx.fillStyle = "rgba(233,236,255,.9)";
                    ctx.font = "12px system-ui";
                    ctx.textAlign = "center";
                    ctx.textBaseline = "middle";
                    ctx.fillText(String(i), 0, 0);

                    // apartment owner dot + beds
                    if (s.type === SPACE.APARTMENT) {
                        if (s.owner !== null) {
                            const owner = g.players[s.owner];
                            ctx.beginPath();
                            ctx.fillStyle = owner.token;
                            ctx.arc(-w / 2 + 18, 0, 5.5, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.strokeStyle = "rgba(255,255,255,.35)";
                            ctx.stroke();
                        }

                        // beds indicator (compact)
                        const beds = s.beds;
                        ctx.fillStyle = "rgba(233,236,255,.9)";
                        ctx.font = "11px system-ui";
                        ctx.textAlign = "right";
                        const bedText = beds === 0 ? "" : ("üõè".repeat(Math.min(3, beds)) + (beds > 3 ? `+${beds - 3}` : ""));
                        ctx.fillText(bedText, w / 2 - 8, 0);
                    }

                    // highlight current player position
                    const cp = currentPlayer(g);
                    if (cp && cp.pos === i) {
                        ctx.strokeStyle = "rgba(255,255,255,.55)";
                        ctx.lineWidth = 2.5;
                        roundRect(-w / 2, -h / 2, w, h, 10);
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                // mini player legend
                let y = 46;
                ctx.save();
                ctx.fillStyle = "rgba(233,236,255,.85)";
                ctx.font = "14px system-ui";
                ctx.textAlign = "left";
                ctx.fillText("Players:", 18, 30);
                for (const p of g.players) {
                    ctx.beginPath();
                    ctx.fillStyle = p.token;
                    ctx.arc(28, y, 7, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = "rgba(255,255,255,.35)";
                    ctx.stroke();
                    ctx.fillStyle = "rgba(233,236,255,.85)";
                    ctx.font = "12px system-ui";
                    ctx.fillText(`${p.name}  $${p.cash}${p.bankrupt ? " (BANKRUPT)" : ""}`, 42, y + 4);
                    y += 18;
                }
                ctx.restore();
            }

            function renderPlayers(g) {
                const wrap = $("players");
                wrap.innerHTML = "";
                g.players.forEach((p, idx) => {
                    const div = document.createElement("div");
                    div.className = "playerBox" + (idx === g.turn ? " active" : "");

                    const left = document.createElement("div");
                    left.className = "playerLeft";

                    const token = document.createElement("div");
                    token.className = "token";
                    token.style.background = p.token;

                    const info = document.createElement("div");
                    const nm = document.createElement("div");
                    nm.className = "playerName";
                    nm.textContent = p.name + (p.bankrupt ? " (BANKRUPT)" : "");

                    const kv = document.createElement("div");
                    kv.className = "kv";
                    kv.innerHTML = `
            <span>Cash: <b>$${p.cash}</b></span>
            <span>Pos: <b>${p.pos}</b></span>
            <span>Apts: <b>${p.owned.length}</b></span>
            <span>Sets: <b>${countCompleteSets(g, p)}</b></span>
          `;

                    info.appendChild(nm);
                    info.appendChild(kv);

                    left.appendChild(token);
                    left.appendChild(info);

                    const right = document.createElement("div");
                    right.className = "kv";
                    right.innerHTML = `
            <span class="badge">x2 Rent: <b>${p.status.doubleNextRent ? "ON" : "off"}</b></span>
            <span class="badge">¬Ω Upgrade: <b>${p.status.halfNextUpgrade ? "ON" : "off"}</b></span>
            <span class="badge">-20% Buy: <b>${p.status.discountNextBuy ? "ON" : "off"}</b></span>
          `;

                    div.appendChild(left);
                    div.appendChild(right);
                    wrap.appendChild(div);
                });
            }

            function renderSpaceInfo(space, g) {
                const el = $("spaceInfo");
                const title = el.querySelector(".big");
                const mini = el.querySelector(".mini");

                title.textContent = `${space.id}: ${space.name}`;

                if (space.type === SPACE.APARTMENT) {
                    const owner = space.owner === null ? "Unowned" : g.players[space.owner].name;
                    const setComplete = (space.owner !== null) ? ownsCompleteSet(g, g.players[space.owner], space.setKey) : false;

                    mini.innerHTML = `
            <div>
              Type: <b>Apartment</b>
              <span class="badge" style="border-color:${space.colorHex}">${space.setName}</span>
              ${setComplete ? `<span class="badge" style="border-color:${space.colorHex}">Complete Set</span>` : ``}
            </div>
            <div>Owner: <b>${owner}</b></div>
            <div>Price: <b>$${space.price}</b> ‚Ä¢ Base rent: <b>$${space.baseRent}</b> ‚Ä¢ Beds: <b>${space.beds}</b> (${BED_NAMES[space.beds]})</div>
            <div>Upgrade cost: <b>$${space.upgradeCost}</b> ‚Ä¢ Current rent: <b>${space.owner === null ? "‚Äî" : ("$" + rentFor(space, g))}</b></div>
          `;
                } else {
                    mini.textContent = space.text || "";
                }
            }

            function renderMarket(g) {
                const el = $("market");
                el.innerHTML = "";
                const unowned = g.spaces
                    .filter(s => s.type === SPACE.APARTMENT && s.owner === null)
                    .sort((a, b) => a.price - b.price);

                if (!unowned.length) {
                    el.innerHTML = `<div class="mini" style="padding:6px 4px;">No unowned apartments left.</div>`;
                    return;
                }

                for (const s of unowned.slice(0, 40)) {
                    const div = document.createElement("div");
                    div.className = "listItem";
                    div.innerHTML = `
            <div class="big">
              <span class="badge" style="border-color:${s.colorHex}">${s.setName}</span>
              ${s.name}
              <span class="badge">$${s.price}</span>
            </div>
            <div class="mini">Base rent $${s.baseRent} ‚Ä¢ Upgrade $${s.upgradeCost}</div>
          `;
                    el.appendChild(div);
                }
                if (unowned.length > 40) {
                    const more = document.createElement("div");
                    more.className = "mini";
                    more.style.padding = "6px 4px 2px";
                    more.textContent = `‚Ä¶and ${unowned.length - 40} more unowned apartments`;
                    el.appendChild(more);
                }
            }

            function renderOwned(g) {
                const el = $("owned");
                el.innerHTML = "";
                const p = currentPlayer(g);
                const owned = p.owned.map(id => g.spaces[id]).sort((a, b) => a.setKey.localeCompare(b.setKey) || a.price - b.price);

                if (!owned.length) {
                    el.innerHTML = `<div class="mini" style="padding:6px 4px;">No properties yet. Buy when you land on an unowned unit.</div>`;
                    return;
                }

                for (const s of owned) {
                    const complete = ownsCompleteSet(g, p, s.setKey);
                    const div = document.createElement("div");
                    div.className = "listItem";
                    div.innerHTML = `
            <div class="big">
              <span class="badge" style="border-color:${s.colorHex}">${s.setName}</span>
              ${s.name}
              <span class="badge">Beds ${s.beds} (${BED_NAMES[s.beds]})</span>
              ${complete ? `<span class="badge" style="border-color:${s.colorHex}">Complete Set</span>` : ``}
            </div>
            <div class="mini">Rent now: <b>$${rentFor(s, g)}</b> ‚Ä¢ Upgrade: <b>$${upgradePrice(s, p)}</b></div>
          `;
                    el.appendChild(div);
                }
            }

            function renderHint(g) {
                const p = currentPlayer(g);
                const s = g.spaces[p.pos];
                const hTitle = $("hintTitle");
                const hText = $("hintText");

                if (g.phase === "NEED_ROLL") {
                    hTitle.textContent = "Roll";
                    hText.textContent = "Tap Roll to move.";
                    return;
                }

                if (s.type === SPACE.APARTMENT) {
                    if (s.owner === null) {
                        hTitle.textContent = "Buy?";
                        hText.textContent = `You can buy this unit for $${buyPrice(s, p)} (or End Turn).`;
                    } else if (s.owner === p.id) {
                        hTitle.textContent = "Upgrade Bed?";
                        hText.textContent = s.beds < 5
                            ? `Upgrade this unit for $${upgradePrice(s, p)} (or upgrade your cheapest unit).`
                            : `This unit is already maxed (Luxury).`;
                    } else {
                        hTitle.textContent = "Rent Paid";
                        hText.textContent = "Rent was handled automatically. End your turn.";
                    }
                    return;
                }

                hTitle.textContent = "End Turn";
                hText.textContent = "Space resolved. End your turn.";
            }

            function disableActions(disabled) {
                $("btnRoll").disabled = disabled;
                $("btnBuy").disabled = disabled;
                $("btnUpgrade").disabled = disabled;
                $("btnEnd").disabled = disabled;
                $("btnForfeit").disabled = disabled;
            }

            function updateUI() {
                if (!game) return;
                const g = game;
                const p = currentPlayer(g);

                $("turnLabel").textContent = `${p.name}'s turn`;
                $("turnDot").style.background = p.token;

                renderPlayers(g);
                renderSpaceInfo(g.spaces[p.pos], g);
                renderMarket(g);
                renderOwned(g);
                renderHint(g);
                drawBoard(g);

                // Button states
                $("btnRoll").disabled = (g.phase !== "NEED_ROLL");
                $("btnEnd").disabled = (g.phase === "NEED_ROLL");

                const s = g.spaces[p.pos];
                $("btnBuy").disabled = !(g.phase === "RESOLVED" && s.type === SPACE.APARTMENT && s.owner === null);

                const canUpgrade =
                    (g.phase === "RESOLVED") &&
                    (
                        (s.type === SPACE.APARTMENT && s.owner === p.id && s.beds < 5) ||
                        (p.owned.some(id => g.spaces[id].beds < 5))
                    );
                $("btnUpgrade").disabled = !canUpgrade;
            }

            // ---------- Log ----------
            function log(msg, cls = "") {
                const el = $("log");
                const div = document.createElement("div");
                div.className = "line " + cls;
                div.textContent = msg;
                el.appendChild(div);
                el.scrollTop = el.scrollHeight;
            }
            function clearLog() { $("log").innerHTML = ""; }

            // ---------- DOM helpers ----------
            function $(id) { return document.getElementById(id); }

            // ---------- Tabs ----------
            function setTab(tab) {
                document.querySelectorAll(".tabBtn").forEach(b => b.classList.toggle("active", b.dataset.tab === tab));
                document.querySelectorAll(".tabPanel").forEach(p => p.classList.remove("active"));
                document.getElementById(`tab-${tab}`).classList.add("active");
            }

            // ---------- Wire up ----------
            document.querySelectorAll(".tabBtn").forEach(btn => {
                btn.addEventListener("click", () => setTab(btn.dataset.tab));
            });

            $("btnClearLog").addEventListener("click", clearLog);

            $("btnNew").addEventListener("click", () => {
                game = null;
                $("setup").style.display = "";
                $("gameUI").style.display = "none";
                $("turnLabel").textContent = "Not started";
                $("turnDot").style.background = "transparent";
                $("diceOut").textContent = "‚Äì";
                clearLog();
                // draw a preview board
                const preview = newGameState(2, 1500);
                drawBoard(preview);
                setTab("actions");
            });

            $("btnStart").addEventListener("click", () => {
                const n = clamp(parseInt($("numPlayers").value, 10), 2, 4);
                const cash0 = Math.max(500, parseInt($("startCash").value, 10) || 1500);

                game = newGameState(n, cash0);

                $("setup").style.display = "none";
                $("gameUI").style.display = "";

                clearLog();
                log("üéâ Game started! Pass Start to collect $200.", "goodTxt");
                log(`‚û°Ô∏è ${currentPlayer(game).name} goes first.`, "warnTxt");

                $("diceOut").textContent = "‚Äì";
                updateUI();
                setTab("board");
            });

            $("btnRoll").addEventListener("click", roll);
            $("btnBuy").addEventListener("click", buy);
            $("btnUpgrade").addEventListener("click", upgrade);
            $("btnEnd").addEventListener("click", endTurn);
            $("btnForfeit").addEventListener("click", forfeit);

            // ---------- Initial preview ----------
            try {
                const preview = newGameState(2, 1500);
                drawBoard(preview);
            } catch (e) {
                console.error(e);
                showFatal(e.message);
            }
        })();
    </script>
</body>
</html>